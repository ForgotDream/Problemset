# 2 月 11 日测试题解

简评：状态不佳。

## T1

### 题意

给你一棵树上每个节点的度，输出这棵树的一种可能的直径或者当无解时输出 $-1$。

### 数据范围

$n \le 20$

### 思路

本题为结论题，并且正解时间复杂度严格线性，不知道为什么这道题数据范围只给到了 $n \le 20$。

>  Lemma 1：任何一棵节点数为 $n$ 树中的节点度数之和为 $2 \times (n - 1)$。

我们知道，节点数为 $n$ 的树中共有 $n - 1$ 条边，每条边对度数的贡献是 $2$，于是引理显然成立。

这个引理的作用是帮助我们快速判断题目中给出的数据是否有解。

>  Lemma 2：存在一种建树方法，使得所有非叶子节点都位于树的直径上。

可以通过数学归纳法证明。

比如说，我们有如下的一棵树：

![pS5gY6I.png](https://s1.ax1x.com/2023/02/12/pS5gY6I.png)

设点 $2$ 的度数为 $d_2$，点 $3$ 的度数为 $d_3$，我们可以通过如下操作，使得它们的度数不变，而将 $2$ 与 $3$ 都转移到同一条链上。为简化问题，我们将 $3$ 转移到 $2$ 的下方。

1. 断开 $2$ 与其子节点中的一个，记为 $son_2$，的连接；
2. 取 $3$ 本身以及 $d_3 - 2$ 个子节点，使其成为 $2$ 的新的子节点，此时 $2$ 的度数还是 $d_2$；
3. 将 $3$ 剩余的一个子节点，记为 $son_3$，挂到 $3$ 原本的位置上，再使 $son_2$ 成为 $3$ 的子节点，此时，$3$ 的度数为 $d_3 - 1 + 1 = d_3$。

最终的效果如下：

![pS52kHf.png](https://s1.ax1x.com/2023/02/12/pS52kHf.png)

我们可以通过相似的操作，使得每个非叶子节点都汇到一条链上，那么上述引理成立。

如果我们通过上述方法建树，这棵树的直径就是 $d = |\{t | t 为非叶子节点\}| + 1$。

### 代码

注意在出现负度数的时候输出 $-1$。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <cstring>

using namespace std;
using i64 = long long;
using i64u = unsigned long long;

const int N = 25;
int n;
int d[N], tot, ans = 1;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> d[i], tot += d[i];

    if (tot != (n - 1) << 1) cout << -1 << '\n';
    else {
        for (int i = 1; i <= n; i++) 
            if (d[i] >= 2) ans++;
            else if (d[i] <= 0) return cout << -1 << '\n', 0;
        cout << ans << '\n';
    }

	return 0;
}

```

## T2

### 题意

给你一个矩阵 $A$ 如下：

$$\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}$$

现在你要构造一个矩阵 $B$：

$$\begin{bmatrix}
a_1 & b_1 \\
c_1 & d_1 \\
\end{bmatrix}$$

满足 $a_1 \times d_1 = c_1 \times d_1$ 且 $A - B$ 中的绝对值最大元素最小。

### 思路

最大值最小，不难想到二分答案。

我们考虑二分一个答案 $ans$，那么有 $a_1 \in [a - ans, a + ans]$，其余三项同理。如果答案小于等于 $ans$，那么满足 $\{m | m = a_1 \times d_1\} \cup \{n | n = b_1 \times c_1\} \neq \emptyset$ 即可。

### 代码

注意处理含负数时的集合边界即可。

```cpp
#include <bits/stdc++.h>

static const double EPS = 1e-6; 

using namespace std;
double a, b, c, d;
double ans;

bool check(double mid) {
	double l1 = min(min((a - mid) * (d - mid), (a + mid) * (d + mid)), 
					min((a - mid) * (d + mid), (a + mid) * (d - mid)));
	double r1 = max(max((a - mid) * (d - mid), (a + mid) * (d + mid)), 
					max((a - mid) * (d + mid), (a + mid) * (d - mid)));
	
	double l2 = min(min((b - mid) * (c - mid), (b + mid) * (c + mid)), 
					min((b - mid) * (c + mid), (b + mid) * (c - mid)));
	double r2 = max(max((b - mid) * (c - mid), (b + mid) * (c + mid)), 
					max((b - mid) * (c + mid), (b + mid) * (c - mid)));
	
	if (r1 + EPS <= l2 || r2 + EPS <= l1) return false;
	else return true;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);

	cin >> a >> b >> c >> d;

	double l = 0, r = 2e9;
	while (l + EPS <= r) {
		double mid = (l + r) / 2;
		if (check(mid)) ans = mid, r = mid;
		else l = mid;
	}

	cout << fixed << setprecision(3) << ans << '\n';
	return 0;
}
```

## T3

简单的矩阵快速幂，不写了。