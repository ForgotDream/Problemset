    A和B   C和D

    A和B和C和D

    A和B中的一种   C和D的一种

    A和B  双重循环  来得到一个f[i]表示花了i这个时间有几种可能  A*B

    进行桶排序，把f按次序的放进x数组中，A*B种可能排个序

    C和D  双重循环  来得到一个g[i]表示花了i这个时间有几种可能  C*D 

    进行桶排序，把g按次序的放进y数组中，C*D种可能排个序

    A*B 一个数组x   C*D的一个数组y   查询存在多少对i,j，使得x[i]+y[j]<=n  （x和y都是有序的）

    x和y都是顺序的。

    

    x[1]  y[?]  一个前缀(1~p) 

    x[2]  y[??]  一个前缀(1~pp)  pp<=p

    x[3]  y[???] 一个前缀(1~ppp)  ppp<=pp

    

    当一个规模解决不了的时候，分成两半  meet in the middle

