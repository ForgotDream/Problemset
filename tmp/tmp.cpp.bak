/**
 * @file    
 * @author  ForgotDream
 * @brief   
 * @date    2023-11-08
 */
#include <cassert>
#include <cmath>
#include <iostream>
#include <numeric>

#pragma region
namespace FastIO {
static constexpr signed bufsize = 1 << 20;
struct is {
  char inbuf[bufsize], *p1 = inbuf, *p2 = inbuf;
  inline char gc() {
    if (p1 == p2) p1 = inbuf, p2 = inbuf + fread(inbuf, 1, bufsize, stdin);
    return p1 == p2 ? EOF : *p1++;
  }
  template <typename T>
  inline void read(T &x) {
    x = 0;
    T f = 1;
    char c = gc();
    while (c < '0' || c > '9') f = (c == '-' ? -f : f), c = gc();
    while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = gc();
    x *= f;
  }
  inline void read(char *s) {
    char c = gc();
    while (c == ' ' || c == '\n' || c == '\r') c = gc();
    while (c != ' ' && c != '\n' && c != '\r') *s++ = c, c = gc();
  }
  inline void read(char &c) {
    c = gc();
    while (c == ' ' || c == '\n' || c == '\r') c = gc();
  }
  inline void read(std::string &s) {
    std::string().swap(s);
    char c = gc();
    while (c == ' ' || c == '\n' || c == '\r') c = gc();
    while (c != ' ' && c != '\n' && c != '\r') s += c, c = gc();
  }
  template <typename T = int>
  inline T read() {
    T res;
    read(res);
    return res;
  }
  template <typename T>
  is &operator>>(T &rhs) { return read(rhs), *this; }
  is &operator>>(char *rhs) { return read(rhs), *this; }
};
struct os {
  char outbuf[bufsize], *pp = outbuf;
  ~os() { flush(); }
  inline void pc(const char &c) {
    if (pp - outbuf == bufsize) fwrite(outbuf, 1, bufsize, stdout), pp = outbuf;
    *pp++ = c;
  }
  template <typename T>
  inline void print(T x) {
    if (x < 0) x = -x, pc('-');
    static T sta[35];
    T top = 0;
    do sta[top++] = x % 10, x /= 10; while (x);
    while (top) pc(sta[--top] + '0');
  }
  inline void print(const char *s) { for (; *s; ++s) pc(*s); }
  inline void print(char *s) { for (; *s; ++s) pc(*s); }
  inline void print(const std::string &s) { for (const auto &c : s) pc(c); }
  inline void print(const char &c) { pc(c); }
  inline void flush() { fwrite(outbuf, 1, pp - outbuf, stdout), pp = outbuf; }
  template <typename T>
  os &operator<<(const T &rhs) { return print(rhs), *this; }
};
}  // namespace FastIO
FastIO::is fin;
FastIO::os fout;
#pragma endregion

using i64 = long long;
using pii = std::pair<int, int>;

// 忌：重构代码
constexpr int N = 1e5 + 50, M = 350, W = 1e5;
int n, m, a[N];
namespace SQRT {
int blk, bcnt, bln[N], lp[M], rp[M];
int vblk, vcnt, vbln[N];
int fa[N];
int find(int u) { return u == fa[u] ? u : fa[u] = find(fa[u]); }
struct Block {
  int s[M], cnt[N];  // `s` 是前缀和，`cnt` 是值域分块的前缀和（这里的前缀和指的都是块间前缀和）
  int rt[N];
  // 这东西就纯纯的跟第二分块是一样的
  int merge(int u, int v) {
    if (rt[v]) fa[rt[u]] = rt[v];
    else rt[v] = rt[u], a[rt[u]] = v;
    int res = cnt[u];
    cnt[v] += cnt[u], cnt[u] = rt[u] = 0;
    return res;
  }
} b[M];
void init() {
  blk = sqrt(n), bcnt = (n - 1) / blk + 1;
  for (int i = 1; i <= bcnt; i++) lp[i] = (i - 1) * blk + 1, rp[i] = i * blk;
  rp[bcnt] = n;
  for (int i = 1; i <= n; i++) bln[i] = (i - 1) / blk + 1;
  vblk = sqrt(W), vcnt = (W - 1) / vblk + 1;
  for (int i = 1; i <= W; i++) vbln[i] = (i - 1) / vblk + 1;
  for (int i = 1; i <= bcnt; i++) {
    for (int j = lp[i]; j <= rp[i]; j++) {
      b[i].cnt[a[j]]++, b[i].s[vbln[a[j]]]++;
    }
  }
  for (int i = 1; i <= bcnt; i++) {
    for (int j = 1; j <= W; j++) b[i].cnt[j] += b[i - 1].cnt[j];
    for (int j = 1; j <= vcnt; j++) b[i].s[j] += b[i - 1].s[j];
  }
}
void modify(int l, int r, int bfr, int aft) {
  int p, d = 0;
  if (bln[l] == bln[r]) {
    p = bln[l];
    for (int i = l; i <= r; i++) {
      if (b[p].find(a[i]) == bfr) {
        a[i] = aft, b[p].s[vbln[bfr]]--, b[p].s[vbln[aft]]++;
        b[p].cnt[bfr]--, b[p].cnt[aft]++, d++;
      }
    }
    for (int i = bln[l] + 1; i <= bcnt; i++) {
      b[i].s[vbln[bfr]] -= d, b[i].s[vbln[aft]] += d;
      b[i].cnt[bfr] -= d, b[i].cnt[aft] += d;
    }
  } else {
    p = bln[l];
    for (int i = l; i <= rp[p]; i++) {
      if (b[p].find(a[i]) == bfr) {
        a[i] = aft, b[p].s[vbln[bfr]]--, b[p].s[vbln[aft]]++;
        b[p].cnt[bfr]--, b[p].cnt[aft]++, d++;
      }
    }
    for (int i = bln[l] + 1; i < bln[r]; i++) {
      b[i].merge(bfr, aft);
      int pre = b[i].cnt[bfr];
      b[i].cnt[bfr] -= pre + d, b[i].cnt[aft] += pre + d;
      b[i].s[vbln[bfr]] -= pre + d, b[i].s[vbln[aft]] += pre + d;
      d += pre;
    }
    p = bln[r];
    for (int i = lp[p]; i <= r; i++) {
      if (b[p].find(a[i]) == bfr) {
        a[i] = aft, b[p].s[vbln[bfr]]--, b[p].s[vbln[aft]]++;
        b[p].cnt[bfr]--, b[p].cnt[aft]++;
      }
    }
    for (int i = bln[r]; i <= bcnt; i++) {
      b[i].s[vbln[bfr]] -= d, b[i].s[vbln[aft]] += d;
      b[i].cnt[bfr] -= d, b[i].cnt[aft] += d;
    }
  }
}
int ts[M], tcnt[N];  // `t` stands for temp
int query(int l, int r, int k) {
  int p;
  if (bln[l] == bln[r]) {
    auto *cur = &b[bln[l]];
    for (int i = l, p = cur->find(a[i]); i <= r; i++, p = cur->find(a[i])) {
      ts[vbln[p]]++, tcnt[p]++;
    }
    p = 1;
    while (k - ts[p] > 0) k -= ts[p++];
    p = vblk * (p - 1) + 1;
    while (k - tcnt[p] > 0) k -= tcnt[p++];
    for (int i = l, p = cur->find(a[i]); i <= r; i++, p = cur->find(a[i])) {
      ts[vbln[p]]--, tcnt[p]--;
    }
    return p;
  } else {
    auto *cur = &b[bln[l]];
    for (int i = l, p = cur->find(a[i]); i <= rp[bln[l]]; i++, p = cur->find(a[i])) {
      ts[vbln[p]]++, tcnt[p]++;
    }
    cur = &b[bln[r]];
    for (int i = lp[bln[r]], p = cur->find(a[i]); i <= r; i++, p = cur->find(a[i])) {
      ts[vbln[p]]++, tcnt[p]++;
    }
    p = 1;
    while (k > ts[p] + b[bln[r] - 1].s[p] - b[bln[l]].s[p]) {
      k -= ts[p] + b[bln[r] - 1].s[p] - b[bln[l]].s[p], p++;
    }
    p = vblk * (p - 1) + 1;
    while (k > tcnt[p] + b[bln[r] - 1].cnt[p] - b[bln[l]].cnt[p]) {
      k -= tcnt[p] + b[bln[r] - 1].cnt[p] - b[bln[l]].cnt[p], p++;
    }
    cur = &b[bln[l]];
    for (int i = l, p = cur->find(a[i]); i <= rp[bln[l]]; i++, p = cur->find(a[i])) {
      ts[vbln[p]]--, tcnt[p]--;
    }
    cur = &b[bln[r]];
    for (int i = lp[bln[r]], p = cur->find(a[i]); i <= r; i++, p = cur->find(a[i])) {
      ts[vbln[p]]--, tcnt[p]--;
    }
    return p;
  }
}
void debug() {
  std::cerr << "------------------ cnt -------------------\n";
  for (int i = 1; i <= bcnt; i++) {
    for (int j = 1; j <= 40; j++) {
      std::cerr << b[i].cnt[j] << " \n"[j == 40];
    }
  }
  std::cerr << "------------------- s --------------------\n";
  for (int i = 1; i <= bcnt; i++) {
    for (int j = 1; j <= 40; j++) {
      std::cerr << b[i].s[j] << " \n"[j == 40];
    }
  }
  std::cerr << "------------------------------------------\n";
  for (int i = 1; i <= n; i++) std::cerr << a[i] << " \n"[i == n];
  std::cerr << "------------------------------------------\n";
}
}  // namespace SQRT
void solve() {
  fin >> n >> m;
  for (int i = 1; i <= n; i++) fin >> a[i];
  SQRT::init();
  // SQRT::debug();
  for (int i = 1, opt, l, r, x, y; i <= m; i++) {
    fin >> opt >> l >> r;
    if (opt == 1) {
      fin >> x >> y;
      SQRT::modify(l, r, x, y);
    } else {
      fin >> x;  // bruh
      fout << SQRT::query(l, r, x) << "\n";
    }
    // SQRT::debug();
  }
}

int main() {
  int t = 1;
  // fin >> t;
  while (t--) solve();
  return 0;
}
